<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì‹¤ì‹œê°„ êµ¬ìŠ¬ ë ˆì´ìŠ¤ - íšŒì „íŒ í•€ë³¼ ë§µ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-database.js"></script>
    <style>
        body { margin: 0; background: #1a1a1b; color: white; font-family: 'Pretendard', sans-serif; display: flex; flex-direction: column; align-items: center; min-height: 100vh; overflow-y: auto; }
        #game-container { position: relative; width: 400px; height: 1600px; background: #2a2a2a; border: 5px solid #333; margin-top: 20px; cursor: crosshair; }
        .controls { background: #333; padding: 15px; border-radius: 10px; width: 370px; margin: 20px 0; z-index: 100; }
        textarea { width: 100%; height: 50px; background: #111; color: white; border: 1px solid #444; padding: 8px; box-sizing: border-box; border-radius: 5px; margin-bottom: 10px; resize: none; }
        .option-group { display: flex; justify-content: space-around; background: #222; padding: 10px; border-radius: 5px; margin-bottom: 10px; }
        button { width: 100%; padding: 12px; margin-top: 5px; cursor: pointer; font-weight: bold; border: none; border-radius: 5px; }
        .small-btn { width: 48%; display: inline-block; }
        #dropBtn { background: #5865F2; color: white; font-size: 1.1rem; }
        #saveBtn { background: #3ba55c; color: white; }
        #resetBtn { background: #ed4245; color: white; }
        #editModeBtn { background: #faa61a; color: white; }
        #saveMapBtn { background: #9b59b6; color: white; }
        #loadMapBtn { background: #3498db; color: white; }
        #clearMapBtn { background: #e74c3c; color: white; }
        #resultDisplay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; font-weight: bold; pointer-events: none; text-shadow: 0 0 20px gold; color: gold; display: none; z-index: 10; text-align: center; width: 100%; white-space: pre-wrap; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .edit-controls { display: none; background: #222; padding: 10px; border-radius: 5px; margin-bottom: 10px; }
        .edit-controls.active { display: block; }
        .tool-group { display: flex; gap: 5px; margin-bottom: 10px; }
        .tool-btn { flex: 1; padding: 8px; background: #444; color: white; border: none; border-radius: 3px; cursor: pointer; }
        .tool-btn.active { background: #5865F2; }
        input[type="range"] { width: 100%; }
        .param-group { margin: 10px 0; }
        .param-group label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
        #editStatus { background: #555; padding: 8px; border-radius: 5px; text-align: center; margin-bottom: 10px; font-size: 0.9rem; }
    </style>
</head>
<body>
    <div class="controls" style="margin-bottom: 5px; background: #2c2f33;">
        <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
            <span style="font-weight: bold; color: #5865F2;">í˜„ì¬ ë°©: <span id="currentRoomDisplay"></span></span>
            <input type="text" id="roomInput" placeholder="ë°© ë²ˆí˜¸ ì…ë ¥" style="width: 80px; padding: 5px; border-radius: 3px; border: none;">
            <button class="small-btn" onclick="changeRoom()" style="width: auto; padding: 5px 15px; margin: 0; background: #5865F2;">ì´ë™</button>
            <button class="small-btn" onclick="randomRoom()" style="width: auto; padding: 5px 15px; margin: 0; background: #72767d;">ëœë¤ ë°©</button>
        </div>
    </div>
    
    <div id="game-container">
        <div id="resultDisplay"></div>
    </div>

    <div class="controls">
        <textarea id="nameInput" placeholder="ì´ë¦„ì„ ì‰¼í‘œë¡œ êµ¬ë¶„ (ì˜ˆ: ì² ìˆ˜, ì˜í¬, ë¯¼ìˆ˜*3)"></textarea>
        <div class="option-group">
            <label><input type="radio" name="winType" value="first" checked> ì²˜ìŒ í†µê³¼</label>
            <label><input type="radio" name="winType" value="last"> ë§ˆì§€ë§‰ í†µê³¼</label>
        </div>
        <button id="saveBtn" onclick="saveData()">âœ… ì„¤ì • ì €ì¥ & êµ¬ìŠ¬ ì„¸íŒ…</button>
        <button id="dropBtn" onclick="triggerDrop()" disabled>ğŸ”® ë ˆì´ìŠ¤ ì‹œì‘!</button>
        <button id="resetBtn" onclick="resetGame()">ğŸ”„ ì´ˆê¸°í™”</button>
        
        <div style="margin-top: 15px; border-top: 2px solid #444; padding-top: 15px;">
            <button id="editModeBtn" onclick="toggleEditMode()">ğŸ› ï¸ ë§µ í¸ì§‘ ëª¨ë“œ</button>
            
            <div id="editControls" class="edit-controls">
                <div id="editStatus">í¸ì§‘ ëª¨ë“œ: í´ë¦­í•˜ì—¬ ì˜¤ë¸Œì íŠ¸ ì¶”ê°€</div>
                
                <div class="tool-group">
                    <button class="tool-btn active" onclick="selectTool('wall')">ğŸ§± ë²½</button>
                    <button class="tool-btn" onclick="selectTool('spinner')">ğŸ”„ íšŒì „íŒ</button>
                    <button class="tool-btn" onclick="selectTool('pin')">ğŸ“ í•€</button>
                    <button class="tool-btn" onclick="selectTool('delete')">ğŸ—‘ï¸ ì‚­ì œ</button>
                </div>
                
                <div class="param-group">
                    <label>í¬ê¸°: <span id="sizeValue">50</span>px</label>
                    <input type="range" id="sizeSlider" min="10" max="200" value="50" oninput="updateSize(this.value)">
                </div>
                
                <div class="param-group">
                    <label>ê°ë„: <span id="angleValue">0</span>Â°</label>
                    <input type="range" id="angleSlider" min="-180" max="180" value="0" oninput="updateAngle(this.value)">
                </div>
                
                <div class="param-group" id="speedControl" style="display:none;">
                    <label>íšŒì „ ì†ë„: <span id="speedValue">0.05</span></label>
                    <input type="range" id="speedSlider" min="-0.1" max="0.1" step="0.01" value="0.05" oninput="updateSpeed(this.value)">
                </div>
                
                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <button class="small-btn" id="saveMapBtn" onclick="saveMap()">ğŸ’¾ ë§µ ì €ì¥</button>
                    <button class="small-btn" id="loadMapBtn" onclick="loadMap()">ğŸ“‚ ë§µ ë¶ˆëŸ¬ì˜¤ê¸°</button>
                </div>
                <button class="tool-btn" onclick="undo()" style="background: #72767d; margin-top:5px;">â†©ï¸ ë˜ëŒë¦¬ê¸° (Ctrl+Z)</button>
                <button id="clearMapBtn" onclick="clearCustomMap()">ğŸ—‘ï¸ ì»¤ìŠ¤í…€ ì˜¤ë¸Œì íŠ¸ ëª¨ë‘ ì‚­ì œ</button>
            </div>
        </div>
    </div>

    <script>
        // === [ì„¤ì •] Firebase Config ===
        const firebaseConfig = {
  apiKey: "AIzaSyBWAt4N6PIoY-ZrZQxbqsxauOF0TBcHZ-E",
  authDomain: "random-game-22f1a.firebaseapp.com",
  databaseURL: "https://random-game-22f1a-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "random-game-22f1a",
  storageBucket: "random-game-22f1a.firebasestorage.app",
  messagingSenderId: "1091564497932",
  appId: "1:1091564497932:web:a16dc96fb998166dea9229"
};
        // ============================

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        let roomId = new URLSearchParams(window.location.search).get('room') || Math.random().toString(36).substring(2, 7);
        if (!window.location.search.includes('room')) window.history.pushState({}, '', `?room=${roomId}`);

        const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;
        const engine = Engine.create();
        engine.gravity.y = 1.0;
        
        const render = Render.create({
            element: document.getElementById('game-container'),
            engine: engine,
            options: { width: 400, height: 1600, wireframes: false, background: '#2a2a2a' }
        });

        const wallOpt = { isStatic: true, render: { fillStyle: '#555' }, friction: 0.001 };
        const pinOpt = { isStatic: true, render: { fillStyle: '#888' }, restitution: 0.5 };

        // ì™¸ê³½ ë²½
        Composite.add(engine.world, [
            Bodies.rectangle(200, 1610, 400, 20, { ...wallOpt, label: 'boundary' }), // ë°”ë‹¥
            Bodies.rectangle(-5, 800, 10, 1600, { ...wallOpt, label: 'boundary' }), // ì™¼ë²½
            Bodies.rectangle(405, 800, 10, 1600, { ...wallOpt, label: 'boundary' }), // ì˜¤ë¥¸ë²½
        ]);

        // ìƒë‹¨ ì…êµ¬ - ê¹”ë•Œê¸° í˜•íƒœ
        Composite.add(engine.world, [
            Bodies.rectangle(80, 100, 140, 10, { ...wallOpt, angle: 0.4, label: 'default' }),
            Bodies.rectangle(320, 100, 140, 10, { ...wallOpt, angle: -0.4, label: 'default' }),
            Bodies.rectangle(60, 180, 100, 10, { ...wallOpt, angle: -0.3, label: 'default' }),
            Bodies.rectangle(340, 180, 100, 10, { ...wallOpt, angle: 0.3, label: 'default' }),
        ]);

        // íšŒì „íŒê³¼ ë²½ ì •ì˜
        const spinners = [];
        
        // ì¤‘ì•™ ì„¹ì…˜ - ìŠ¤í”¼ì»¤ í˜•íƒœ (íšŒì „íŒê³¼ ê¸´ ë²½)
        Composite.add(engine.world, [
            Bodies.rectangle(130, 380, 8, 180, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(130, 590, 8, 200, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(270, 380, 8, 180, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(270, 590, 8, 200, { ...wallOpt, label: 'default' }),
        ]);

        // ì¤‘ì•™ ìŠ¤í”¼ì»¤ ë¶€ë¶„ì˜ íšŒì „íŒë“¤
        const speakerSpinners = [
            {x: 160, y: 460, w: 28, h: 5, speed: 0.03},
            {x: 190, y: 460, w: 28, h: 5, speed: -0.03},
            {x: 160, y: 500, w: 28, h: 5, speed: -0.03},
            {x: 190, y: 500, w: 28, h: 5, speed: 0.03},
            {x: 160, y: 540, w: 28, h: 5, speed: 0.03},
            {x: 190, y: 540, w: 28, h: 5, speed: -0.03},
            {x: 210, y: 460, w: 28, h: 5, speed: 0.03},
            {x: 240, y: 460, w: 28, h: 5, speed: -0.03},
            {x: 210, y: 500, w: 28, h: 5, speed: -0.03},
            {x: 240, y: 500, w: 28, h: 5, speed: 0.03},
            {x: 210, y: 540, w: 28, h: 5, speed: 0.03},
            {x: 240, y: 540, w: 28, h: 5, speed: -0.03},
        ];

        speakerSpinners.forEach(s => {
            const spinner = Bodies.rectangle(s.x, s.y, s.w, s.h, {
                isStatic: true,
                render: { fillStyle: '#4a9eff' },
                chamfer: { radius: 2 },
                friction: 0,
                frictionStatic: 0,
                label: 'default'
            });
            spinners.push({ body: spinner, speed: s.speed, type: 'rect' });
            Composite.add(engine.world, spinner);
        });

        // ì¤‘ë‹¨ ì„¹ì…˜
        Composite.add(engine.world, [
            Bodies.rectangle(80, 800, 8, 250, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(320, 800, 8, 250, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(80, 1100, 8, 200, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(320, 1100, 8, 200, { ...wallOpt, label: 'default' }),
        ]);

        // ì¤‘ë‹¨ íšŒì „íŒë“¤
        const middleSpinners = [
            {x: 120, y: 750, w: 40, h: 6, speed: 0.04},
            {x: 280, y: 820, w: 40, h: 6, speed: -0.04},
            {x: 120, y: 900, w: 40, h: 6, speed: -0.035},
            {x: 280, y: 970, w: 40, h: 6, speed: 0.035},
            {x: 120, y: 1050, w: 40, h: 6, speed: 0.04},
            {x: 280, y: 1120, w: 40, h: 6, speed: -0.04},
            {x: 120, y: 1200, w: 40, h: 6, speed: -0.035},
        ];

        middleSpinners.forEach(s => {
            const spinner = Bodies.rectangle(s.x, s.y, s.w, s.h, {
                isStatic: true,
                render: { fillStyle: '#ff6b6b' },
                chamfer: { radius: 3 },
                friction: 0,
                frictionStatic: 0,
                label: 'default'
            });
            spinners.push({ body: spinner, speed: s.speed, type: 'rect' });
            Composite.add(engine.world, spinner);
        });

        // í•€ë³¼ í•€ë“¤
        const pins = [];
        for (let row = 0; row < 12; row++) {
            const y = 750 + row * 55;
            const offset = row % 2 === 0 ? 0 : 25;
            for (let col = 0; col < 6; col++) {
                const x = 120 + col * 40 + offset;
                if (x > 100 && x < 300) {
                    pins.push(Bodies.circle(x, y, 5, { ...pinOpt, label: 'default' }));
                }
            }
        }
        Composite.add(engine.world, pins);

        // í•˜ë‹¨ ê¹”ë•Œê¸°
        Composite.add(engine.world, [
            Bodies.rectangle(90, 1340, 200, 10, { ...wallOpt, angle: 0.55, label: 'default' }),
            Bodies.rectangle(310, 1340, 200, 10, { ...wallOpt, angle: -0.55, label: 'default' }),
            Bodies.rectangle(130, 1440, 10, 150, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(270, 1440, 10, 150, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(180, 1530, 10, 180, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(220, 1530, 10, 180, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(165, 1540, 10, 100, { ...wallOpt, label: 'default' }),
            Bodies.rectangle(235, 1540, 10, 100, { ...wallOpt, label: 'default' }),
        ]);

        // í•˜ë‹¨ ê²½ì‚¬ë¡œ
        Composite.add(engine.world, [
            Bodies.rectangle(165, 1490, 45, 8, { ...wallOpt, angle: 0.25, label: 'default' }),
            Bodies.rectangle(235, 1510, 45, 8, { ...wallOpt, angle: -0.25, label: 'default' }),
        ]);

        // ì‹œì‘ ê²Œì´íŠ¸
        const gate = Bodies.rectangle(200, 50, 350, 15, { 
            isStatic: true, 
            render: { fillStyle: '#ff0000', opacity: 0.7 },
            label: 'gate'
        });
        Composite.add(engine.world, gate);

        Render.run(render);
        Runner.run(Runner.create(), engine);

        // í¸ì§‘ ëª¨ë“œ ë³€ìˆ˜
        let editMode = false;
        let currentTool = 'wall';
        let currentSize = 50;
        let currentAngle = 0;
        let currentSpeed = 0.05;

        // ë§µ í´ë¦­ ì´ë²¤íŠ¸
        document.getElementById('game-container').addEventListener('click', (e) => {
            if (!editMode) return;
            
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentTool === 'delete') {
                deleteObjectAt(x, y);
            } else {
                addObject(x, y);
            }
        });

        function toggleEditMode() {
            editMode = !editMode;
            const btn = document.getElementById('editModeBtn');
            const controls = document.getElementById('editControls');
            
            if (editMode) {
                btn.style.background = '#e67e22';
                btn.textContent = 'âœ… í¸ì§‘ ì™„ë£Œ';
                controls.classList.add('active');
            } else {
                btn.style.background = '#faa61a';
                btn.textContent = 'ğŸ› ï¸ ë§µ í¸ì§‘ ëª¨ë“œ';
                controls.classList.remove('active');
            }
        }

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const speedControl = document.getElementById('speedControl');
            speedControl.style.display = tool === 'spinner' ? 'block' : 'none';
            
            const status = document.getElementById('editStatus');
            const toolNames = {
                'wall': 'ë²½',
                'spinner': 'íšŒì „íŒ',
                'pin': 'í•€',
                'delete': 'ì‚­ì œ ëª¨ë“œ'
            };
            status.textContent = `í¸ì§‘ ëª¨ë“œ: ${toolNames[tool]} - í´ë¦­í•˜ì—¬ ${tool === 'delete' ? 'ì‚­ì œ' : 'ì¶”ê°€'}`;
        }

        function updateSize(value) {
            currentSize = parseInt(value);
            document.getElementById('sizeValue').textContent = value;
        }

        function updateAngle(value) {
            currentAngle = parseFloat(value) * Math.PI / 180;
            document.getElementById('angleValue').textContent = value;
        }

        function updateSpeed(value) {
            currentSpeed = parseFloat(value);
            document.getElementById('speedValue').textContent = value;
        }

        // === ë˜ëŒë¦¬ê¸°(Undo) ê´€ë ¨ ë³€ìˆ˜ ===
        let undoStack = [];

        // ì´ë²¤íŠ¸ë¥¼ ìŠ¤íƒì— ì €ì¥í•˜ëŠ” í•¨ìˆ˜
        function pushToUndoStack(type, data) {
            undoStack.push({ type, data });
            if (undoStack.length > 50) undoStack.shift(); // ìµœëŒ€ 50ê°œê¹Œì§€ ê¸°ì–µ
        }

        function addObject(x, y) {
            let body;
            let commonOptions = {
                isStatic: true,
                angle: currentAngle,
                label: 'custom',
                myInternalData: {
                    w: currentTool === 'pin' ? currentSize / 5 : currentSize,
                    h: currentTool === 'pin' ? currentSize / 5 : (currentTool === 'spinner' ? 8 : 10),
                    origSize: currentSize
                }
            };

            if (currentTool === 'wall') {
                body = Bodies.rectangle(x, y, currentSize, 10, { ...commonOptions, render: { fillStyle: '#00ff00' } });
            } else if (currentTool === 'spinner') {
                body = Bodies.rectangle(x, y, currentSize, 8, { ...commonOptions, render: { fillStyle: '#ffff00' }, chamfer: { radius: 3 } });
                spinners.push({ body: body, speed: currentSpeed, type: 'rect' });
            } else if (currentTool === 'pin') {
                body = Bodies.circle(x, y, currentSize / 5, { ...commonOptions, render: { fillStyle: '#ff00ff' }, restitution: 0.5 });
            }

            if (body) {
                Composite.add(engine.world, body);
                // ìƒì„± ê¸°ë¡ ì €ì¥
                pushToUndoStack('add', { body: body });
            }
        }
        
        function deleteObjectAt(x, y) {
            const bodies = Composite.allBodies(engine.world);
            for (let body of bodies) {
                if (body.label !== 'custom' && body.label !== 'default') continue;

                const bounds = body.bounds;
                if (x >= bounds.min.x && x <= bounds.max.x && y >= bounds.min.y && y <= bounds.max.y) {
                    
                    // ì‚­ì œ ì „ ì •ë³´ ë°±ì—…
                    const spinner = spinners.find(s => s.body === body);
                    const backup = {
                        label: body.label,
                        type: body.circleRadius ? 'pin' : (spinner ? 'spinner' : 'wall'),
                        x: body.position.x,
                        y: body.position.y,
                        width: body.myInternalData ? body.myInternalData.w : (body.parts[0].vertices[1].x - body.parts[0].vertices[0].x),
                        height: body.myInternalData ? body.myInternalData.h : (body.parts[0].vertices[2].y - body.parts[0].vertices[1].y),
                        angle: body.angle,
                        speed: spinner ? spinner.speed : 0,
                        radius: body.circleRadius || 0,
                        color: body.render.fillStyle
                    };

                    pushToUndoStack('delete', backup);

                    // ì‹¤ì œ ì‚­ì œ
                    Composite.remove(engine.world, body);
                    if (spinner) {
                        const idx = spinners.indexOf(spinner);
                        spinners.splice(idx, 1);
                    }
                    break;
                }
            }
        }
        
        let dragStart = null;

        const gameContainer = document.getElementById('game-container');

        // ë§ˆìš°ìŠ¤ ëˆ„ë¥¼ ë•Œ (ì‹œì‘ì  ì €ì¥)
        gameContainer.addEventListener('mousedown', (e) => {
            if (!editMode || currentTool === 'delete' || currentTool === 'pin') return;
            const rect = gameContainer.getBoundingClientRect();
            dragStart = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        });

        // ë§ˆìš°ìŠ¤ ë—„ ë•Œ (ì„  ê·¸ë¦¬ê¸° ì™„ë£Œ)
        gameContainer.addEventListener('mouseup', (e) => {
            if (!editMode) return;
            
            const rect = gameContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'delete') {
                deleteObjectAt(x, y);
            } else if (currentTool === 'pin') {
                addObject(x, y); // í•€ì€ ê¸°ì¡´ì²˜ëŸ¼ í´ë¦­ ì§€ì ì— ìƒì„±
            } else if (dragStart) {
                // ë“œë˜ê·¸ ê±°ë¦¬ì— ë”°ë¥¸ ë²½/íšŒì „íŒ ìƒì„±
                addDraggedObject(dragStart.x, dragStart.y, x, y);
            }
            dragStart = null;
        });

        function addDraggedObject(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // ë„ˆë¬´ ì§§ê²Œ ë“œë˜ê·¸í•˜ë©´ ìƒì„±í•˜ì§€ ì•ŠìŒ (ì‹¤ìˆ˜ ë°©ì§€)
            if (distance < 5) return;

            const angle = Math.atan2(dy, dx);
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const thickness = (currentTool === 'spinner') ? 8 : 10;

            let body;
            let options = {
                isStatic: true,
                angle: angle,
                label: 'custom',
                myInternalData: { w: distance, h: thickness }
            };

            if (currentTool === 'wall') {
                body = Bodies.rectangle(midX, midY, distance, thickness, {
                    ...options,
                    render: { fillStyle: '#00ff00' },
                    friction: 0.001
                });
            } else if (currentTool === 'spinner') {
                body = Bodies.rectangle(midX, midY, distance, thickness, {
                    ...options,
                    render: { fillStyle: '#ffff00' },
                    chamfer: { radius: 3 }
                });
                spinners.push({ body: body, speed: currentSpeed, type: 'rect' });
            }

            if (body) {
                Composite.add(engine.world, body);
                pushToUndoStack('add', { body: body });
            }
        }

        // 1. ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì  ë³€ìˆ˜ ì¶”ê°€
        let mousePos = { x: 0, y: 0 };

        // ë§ˆìš°ìŠ¤ ì´ë™ ê°ì§€ ì´ë²¤íŠ¸
        gameContainer.addEventListener('mousemove', (e) => {
            if (!editMode) return;
            const rect = gameContainer.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
        });

        // 2. ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ê°€ì´ë“œ ë Œë”ë§ (Events.on(render, 'afterRender', ...) ë‚´ë¶€ì— ì¶”ê°€)
        Events.on(render, 'afterRender', () => {
            const ctx = render.context;

            // í¸ì§‘ ëª¨ë“œì¼ ë•Œë§Œ ê°€ì´ë“œ í‘œì‹œ
            if (editMode) {
                ctx.save();
                ctx.globalAlpha = 0.4; // íë¦¬ê²Œ í‘œì‹œ (40% íˆ¬ëª…ë„)

                if (currentTool === 'pin') {
                    // í•€ ë¯¸ë¦¬ë³´ê¸° (ì›í˜•)
                    ctx.beginPath();
                    ctx.arc(mousePos.x, mousePos.y, currentSize / 5, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff00ff';
                    ctx.fill();
                    ctx.closePath();
                } 
                else if (currentTool === 'spinner' && !dragStart) {
                    // íšŒì „íŒ ë¯¸ë¦¬ë³´ê¸° (íšŒì „í•˜ì§€ ì•ŠëŠ” ê¸°ë³¸ ì‚¬ê°í˜• ìƒíƒœ í‘œì‹œ)
                    // ë“œë˜ê·¸ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ë§ˆìš°ìŠ¤ ì»¤ì„œë¥¼ ë”°ë¼ë‹¤ë‹˜
                    ctx.translate(mousePos.x, mousePos.y);
                    ctx.rotate(currentAngle);
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(-currentSize / 2, -4, currentSize, 8);
                }
                else if (currentTool === 'wall' && !dragStart) {
                    // ë²½ ë¯¸ë¦¬ë³´ê¸°
                    ctx.translate(mousePos.x, mousePos.y);
                    ctx.rotate(currentAngle);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(-currentSize / 2, -5, currentSize, 10);
                }
                // ë“œë˜ê·¸ ì¤‘ì¼ ë•Œ ì„  ë¯¸ë¦¬ë³´ê¸°
                if (dragStart && (currentTool === 'wall' || currentTool === 'spinner')) {
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]); // ì ì„  í‘œì‹œ
                    ctx.moveTo(dragStart.x, dragStart.y);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.strokeStyle = currentTool === 'wall' ? '#00ff00' : '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]); // ì ì„  ì´ˆê¸°í™”
                    ctx.closePath();
                }

                ctx.restore();
            }

            // ê¸°ì¡´ ì´ë¦„í‘œ ë Œë”ë§ ë¡œì§ (ìœ ì§€)
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            // ... (ê¸°ì¡´ ì´ë¦„í‘œ ì½”ë“œ ìƒëµ)
        });

        function undo() {
            if (undoStack.length === 0) return;
            const action = undoStack.pop();

            if (action.type === 'add') {
                // ì¶”ê°€í–ˆë˜ ê²ƒì„ ì‚­ì œ
                Composite.remove(engine.world, action.data.body);
                const sIdx = spinners.findIndex(s => s.body === action.data.body);
                if (sIdx !== -1) spinners.splice(sIdx, 1);
            } 
            else if (action.type === 'delete') {
                // ì‚­ì œí–ˆë˜ ê²ƒì„ ë‹¤ì‹œ ìƒì„±
                const obj = action.data;
                let body;
                let options = {
                    isStatic: true,
                    angle: obj.angle,
                    label: obj.label,
                    render: { fillStyle: obj.color },
                    myInternalData: { w: obj.width, h: obj.height }
                };

                if (obj.type === 'pin') {
                    body = Bodies.circle(obj.x, obj.y, obj.radius, { ...options, restitution: 0.5 });
                } else {
                    body = Bodies.rectangle(obj.x, obj.y, obj.width, obj.height, options);
                    if (obj.type === 'spinner') {
                        spinners.push({ body: body, speed: obj.speed, type: 'rect' });
                    }
                }
                Composite.add(engine.world, body);
            }
        }

        // Ctrl + Z ë‹¨ì¶•í‚¤ ì´ë²¤íŠ¸
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') {
                undo();
            }
        });

        function saveMap() {
            const allMapObjects = [];
            const bodies = Composite.allBodies(engine.world);
            
            bodies.forEach(body => {
                // ì»¤ìŠ¤í…€ê³¼ ê¸°ë³¸ ìš”ì†Œë¥¼ ëª¨ë‘ ì €ì¥ (ì™¸ê³½ë²½ê³¼ ê²Œì´íŠ¸ ì œì™¸)
                if (body.label === 'custom' || body.label === 'default') {
                    const spinner = spinners.find(s => s.body === body);
                    
                    // ê¸°ë³¸ ìš”ì†Œ(default)ëŠ” myInternalDataê°€ ì—†ìœ¼ë¯€ë¡œ ìˆ˜ë™ ê³„ì‚°
                    let w, h;
                    if (body.myInternalData) {
                        w = body.myInternalData.w;
                        h = body.myInternalData.h;
                    } else {
                        // ê¸°ë³¸ ì‚¬ê°í˜•ë“¤ í¬ê¸° ì—­ì‚° (íšŒì „ ì•ˆ ëœ ìƒíƒœ ê¸°ì¤€)
                        w = body.parts[0].vertices[1].x - body.parts[0].vertices[0].x;
                        h = body.parts[0].vertices[2].y - body.parts[0].vertices[1].y;
                    }

                    allMapObjects.push({
                        label: body.label, // custom ë˜ëŠ” default êµ¬ë¶„
                        type: body.circleRadius ? 'pin' : (spinner ? 'spinner' : 'wall'),
                        x: body.position.x,
                        y: body.position.y,
                        width: w,
                        height: h,
                        angle: body.angle,
                        speed: spinner ? spinner.speed : 0,
                        radius: body.circleRadius || 0,
                        renderColor: body.render.fillStyle
                    });
                }
            });
            
            db.ref(`rooms/${roomId}/customMap`).set(allMapObjects);
            alert('ê¸°ì¡´ ìš”ì†Œë¥¼ í¬í•¨í•œ ëª¨ë“  ë§µì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        function loadMap() {
            db.ref(`rooms/${roomId}/customMap`).once('value', snap => {
                const mapData = snap.val();
                if (!mapData) {
                    alert('ì €ì¥ëœ ë§µì´ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                // ê¸°ì¡´ì˜ ëª¨ë“  ë§µ ì˜¤ë¸Œì íŠ¸ ì‚­ì œ
                clearCustomMap();
                
                mapData.forEach(obj => {
                    let body;
                    let options = {
                        isStatic: true,
                        angle: obj.angle,
                        label: obj.label, // ì €ì¥ëœ ë¼ë²¨ ë³µì›
                        render: { fillStyle: obj.renderColor },
                        myInternalData: { w: obj.width, h: obj.height }
                    };

                    if (obj.type === 'pin') {
                        body = Bodies.circle(obj.x, obj.y, obj.radius, {
                            ...options,
                            restitution: 0.5
                        });
                    } else {
                        body = Bodies.rectangle(obj.x, obj.y, obj.width, obj.height, options);
                        if (obj.type === 'spinner') {
                            spinners.push({ body: body, speed: obj.speed, type: 'rect' });
                        }
                    }
                    if (body) Composite.add(engine.world, body);
                });
                alert('ëª¨ë“  ìš”ì†Œë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!');
            });
        }

        function clearCustomMap() {
            const bodies = Composite.allBodies(engine.world);
    // 'custom'ê³¼ 'default' ëª¨ë‘ ì‚­ì œ
            const deletableBodies = bodies.filter(b => b.label === 'custom' || b.label === 'default');
            deletableBodies.forEach(body => {
                Composite.remove(engine.world, body);
                const spinnerIndex = spinners.findIndex(s => s.body === body);
                if (spinnerIndex !== -1) {
                    spinners.splice(spinnerIndex, 1);
                }
            });
        }
        // íšŒì „íŒ ì• ë‹ˆë©”ì´ì…˜ + êµ¬ìŠ¬ ê°‡í˜ ë°©ì§€
        Events.on(engine, 'beforeUpdate', () => {
            spinners.forEach(s => {
                Body.setAngle(s.body, s.body.angle + s.speed);
            });

            const balls = Composite.allBodies(engine.world).filter(b => !b.isStatic && b.label !== 'gate');
            balls.forEach(ball => {
                if (!ball.stuckTimer) ball.stuckTimer = {};
                
                spinners.forEach((s, idx) => {
                    const dx = ball.position.x - s.body.position.x;
                    const dy = ball.position.y - s.body.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 30) {
                        if (!ball.stuckTimer[idx]) {
                            ball.stuckTimer[idx] = Date.now();
                        } else if (Date.now() - ball.stuckTimer[idx] > 2000) {
                            Body.applyForce(ball, ball.position, { x: 0, y: 0.002 });
                            Body.applyForce(ball, ball.position, { x: (Math.random() - 0.5) * 0.001, y: 0 });
                            ball.stuckTimer[idx] = Date.now();
                        }
                    } else {
                        ball.stuckTimer[idx] = null;
                    }
                });
                
                if (ball.position.y > 1400) {
                    if (ball.position.x < 170) {
                        Body.applyForce(ball, ball.position, { x: 0.0005, y: 0 });
                    } else if (ball.position.x > 230) {
                        Body.applyForce(ball, ball.position, { x: -0.0005, y: 0 });
                    }
                }
            });
        });

        // ì´ë¦„í‘œ ë Œë”ë§
        Events.on(render, 'afterRender', () => {
            const ctx = render.context;
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            Composite.allBodies(engine.world).forEach(body => {
                if (body.label && body.label !== 'Body' && body.label !== 'gate' && !body.isStatic) {
                    ctx.fillStyle = "rgba(0,0,0,0.7)";
                    const tw = ctx.measureText(body.label).width;
                    ctx.fillRect(body.position.x - tw/2 - 3, body.position.y - 28, tw + 6, 16);
                    ctx.fillStyle = "white";
                    ctx.fillText(body.label, body.position.x, body.position.y - 16);
                }
            });
        });

        let names = [];
        let winCondition = 'first';
        let isRunning = false;
        let marblesCreated = false;
        let savedNameInput = '';

        db.ref(`rooms/${roomId}/config`).on('value', snap => {
            const val = snap.val();
            if (val && val.shouldSetup) {
                document.getElementById('nameInput').value = val.names || "";
                savedNameInput = val.names || "";
                winCondition = val.winType || 'first';
                parseNames(val.names);
                setupMarbles();
                db.ref(`rooms/${roomId}/config/shouldSetup`).set(null);
            }
        });

        db.ref(`rooms/${roomId}/drop`).on('value', snap => { 
            if (snap.val() && marblesCreated) startRace(); 
        });

        db.ref(`rooms/${roomId}/reset`).on('value', snap => {
            if (snap.val()) {
                performReset();
                db.ref(`rooms/${roomId}/reset`).set(null);
            }
        });

        function parseNames(str) {
            names = [];
            str.split(',').forEach(n => {
                let part = n.trim();
                if (part.includes('*')) {
                    let [nm, count] = part.split('*');
                    for (let i = 0; i < (parseInt(count) || 1); i++) names.push(nm.trim());
                } else if (part) names.push(part);
            });
        }

        function setupMarbles() {
            if (isRunning) return;
            
            const balls = Composite.allBodies(engine.world).filter(b => !b.isStatic && b.label !== 'gate');
            balls.forEach(b => Composite.remove(engine.world, b));
            
            document.getElementById('resultDisplay').style.display = 'none';

            if (names.length === 0) {
                alert('ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                document.getElementById('dropBtn').disabled = true;
                marblesCreated = false;
                return;
            }
            const existingGate = Composite.allBodies(engine.world).find(b => b.label === 'gate');
            if (!existingGate) {
                Composite.add(engine.world, gate);
            }

            names.forEach((name, i) => {
                const ball = Bodies.circle(180 + (Math.random() * 40), 30, 9, {
                    restitution: 0.5, 
                    friction: 0.001, 
                    frictionAir: 0.01,
                    density: 0.001, 
                    label: name,
                    render: { fillStyle: `hsl(${Math.random() * 360}, 80%, 60%)` }
                });
                Composite.add(engine.world, ball);
            });

            marblesCreated = true;
            document.getElementById('dropBtn').disabled = false;
        }

        function saveData() {
            const inputValue = document.getElementById('nameInput').value.trim();
            if (!inputValue) {
                alert('ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }

            savedNameInput = inputValue;
            const config = { 
                names: inputValue, 
                winType: document.querySelector('input[name="winType"]:checked').value,
                shouldSetup: true
            };
            db.ref(`rooms/${roomId}/config`).set(config);
            db.ref(`rooms/${roomId}/drop`).set(null);
        }

        function triggerDrop() { 
            if (marblesCreated) {
                db.ref(`rooms/${roomId}/drop`).set(Date.now()); 
            }
        }

        function resetGame() {
            db.ref(`rooms/${roomId}/reset`).set(Date.now());
        }

        function performReset() {
            const balls = Composite.allBodies(engine.world).filter(b => !b.isStatic && b.label !== 'gate');
            balls.forEach(b => Composite.remove(engine.world, b));
            
            const existingGate = Composite.allBodies(engine.world).find(b => b.label === 'gate');
            if (!existingGate) {
                Composite.add(engine.world, gate);
            }
            
            document.getElementById('resultDisplay').style.display = 'none';
            isRunning = false;
            marblesCreated = false;
            
            document.getElementById('dropBtn').disabled = true;
            
            db.ref(`rooms/${roomId}/drop`).set(null);
        }

        function startRace() {
            if (isRunning || !marblesCreated) return;
            isRunning = true;
            
            const gateBody = Composite.allBodies(engine.world).find(b => b.label === 'gate');
            if (gateBody) {
                Composite.remove(engine.world, gateBody);
            }
            
            let finished = 0;
            const total = names.length;

            // ì¶©ëŒ ê°ì§€ ì´ë²¤íŠ¸ ë“±ë¡ (í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ë„ë¡ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ê´€ë¦¬)
            const collisionHandler = (event) => {
                event.pairs.forEach((pair) => {
                    const { bodyA, bodyB } = pair;
                    
                    // ë‘ ë¬¼ì²´ ì¤‘ í•˜ë‚˜ê°€ 'boundary'(ë°”ë‹¥)ì´ê³  ë‹¤ë¥¸ í•˜ë‚˜ê°€ êµ¬ìŠ¬ì¼ ë•Œ
                    const ball = [bodyA, bodyB].find(b => !b.isStatic && b.label !== 'boundary' && b.label !== 'gate' && !b.isDone);
                    const isFloor = [bodyA, bodyB].some(b => b.label === 'boundary' && b.position.y > 1500);

                    if (ball && isFloor) {
                        ball.isDone = true;
                        finished++;

                        // ë‹¹ì²¨ì ì¶œë ¥
                        if (winCondition === 'first' && finished === 1) {
                            showWinner(ball.label);
                        } else if (winCondition === 'last' && finished === total) {
                            showWinner(ball.label);
                        }

                        // ë‹¿ì€ ì¦‰ì‹œ ì‚­ì œ
                        Composite.remove(engine.world, ball);

                        // ëª¨ë“  êµ¬ìŠ¬ì´ ë„ì°©í•˜ë©´ ì´ë²¤íŠ¸ í•´ì œ ë° ìƒíƒœ ì´ˆê¸°í™”
                        if (finished === total) {
                            Events.off(engine, 'collisionStart', collisionHandler);
                            isRunning = false;
                        }
                    }
                });
            };

            Events.on(engine, 'collisionStart', collisionHandler);
        }
        
        function showWinner(name) {
            const res = document.getElementById('resultDisplay');
            res.innerText = `ğŸ† ë‹¹ì²¨ ğŸ†\n${name}`;
            res.style.display = 'block';
        }


        // 1. í˜ì´ì§€ ë¡œë“œ ì‹œ í˜„ì¬ ë°© ë²ˆí˜¸ í‘œì‹œ
        document.getElementById('currentRoomDisplay').textContent = roomId;

// 2. íŠ¹ì • ë°© ë²ˆí˜¸ë¡œ ì´ë™í•˜ëŠ” í•¨ìˆ˜
        function changeRoom() {
            const newRoom = document.getElementById('roomInput').value.trim();
            if (newRoom) {
        // URLì˜ room íŒŒë¼ë¯¸í„°ë¥¼ ë³€ê²½í•˜ê³  ìƒˆë¡œê³ ì¹¨
                window.location.href = `?room=${newRoom}`;
            } else {
                alert("ì´ë™í•  ë°© ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            }
        }

// 3. ì™„ì „íˆ ìƒˆë¡œìš´ ëœë¤ ë°© ìƒì„± í•¨ìˆ˜
        function randomRoom() {
            const newId = Math.random().toString(36).substring(2, 7);
            window.location.href = `?room=${newId}`;
        }

// ì—”í„° í‚¤ ì…ë ¥ ì‹œ ì´ë™ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
        document.getElementById('roomInput').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') changeRoom();
        });
    </script>
</body>
</html>
